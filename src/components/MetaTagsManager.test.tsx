import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import MetaTagsManager from './MetaTagsManager'; // Adjust path
import { useToast } from '@/hooks/use-toast';
import * as geminiService from '@/lib/geminiService';

// Mock lucide-react icons
jest.mock('lucide-react', () => ({
  ...jest.requireActual('lucide-react'),
  Globe: () => <div data-testid="globe-icon" />,
  Sparkles: () => <div data-testid="sparkles-icon" />,
  Wand2: () => <div data-testid="wand2-icon" />,
  Copy: () => <div data-testid="copy-icon" />,
  Check: () => <div data-testid="check-icon" />,
  CheckCircle: () => <div data-testid="checkcircle-icon" />,
  AlertTriangle: () => <div data-testid="alerttriangle-icon" />,
}));

// Mock useToast
jest.mock('@/hooks/use-toast', () => ({
  useToast: jest.fn(),
}));

// Mock geminiService
jest.mock('@/lib/geminiService');

describe('MetaTagsManager Component', () => {
  const mockToastFn = jest.fn();
  const mockCallGeminiApi = geminiService.generateBlogContent as jest.Mock; // Using generateBlogContent as the generic caller

  beforeEach(() => {
    jest.clearAllMocks();
    (useToast as jest.Mock).mockReturnValue({ toast: mockToastFn });
    // Reset autoEnhanced flag for tests that rely on auto-generation effect
    // This might require exposing a reset or re-rendering the component if the flag is internal and sticky.
    // For now, we assume tests that need auto-generation will provide enough content to trigger it.
  });

  test('renders initial elements correctly', () => {
    render(<MetaTagsManager />);
    expect(screen.getByText(/Smart Meta Tags Manager/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Main Content/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'EN' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'TH' })).toBeInTheDocument();
    // Initially, generate button might not be there if content is short
  });

  test('shows error if content is empty when generate is clicked manually', async () => {
    render(<MetaTagsManager />);
    // Type some short content to make the button appear (if it's conditional)
    const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
    await userEvent.type(contentTextarea, 'short'); // Content < 100 chars won't auto-trigger

    const generateButton = await screen.findByRole('button', { name: /Generate Meta Tags with AI/i });
    fireEvent.click(generateButton);

    // Clear the content to test the empty validation
    await userEvent.clear(contentTextarea);
    fireEvent.click(generateButton);

    expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
      title: "Please enter content",
      variant: "destructive",
    }));
    expect(mockCallGeminiApi).not.toHaveBeenCalled();
  });

  describe('Gemini API Integration for Meta Tag Generation', () => {
    const mockApiResponseEn = `
Title: Test English Title from AI
Description: This is a test English description generated by AI.
Keywords: test, english, ai, generation
    `;
    const mockApiResponseTh = `
Title: ทดสอบหัวข้อภาษาไทยจาก AI
Description: นี่คือคำอธิบายภาษาไทยทดสอบที่สร้างโดย AI
Keywords: ทดสอบ, ภาษาไทย, เอไอ, การสร้าง
    `;
    const mockApiError = { message: "Network error during meta tag generation.", isApiKeyInvalid: false };
    const mockApiKeyError = { message: "API key invalid. Please go to Settings to add it.", isApiKeyInvalid: true };

    test('auto-generates meta tags on sufficient content input (English)', async () => {
      mockCallGeminiApi.mockResolvedValueOnce(mockApiResponseEn);
      render(<MetaTagsManager />);

      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      // Type enough content to trigger auto-generation (content.length > 100)
      await userEvent.type(contentTextarea, 'This is a long piece of English content, certainly more than one hundred characters, to trigger the automatic generation of meta tags by our very smart AI system.');

      expect(screen.getByText(/Generating.../i)).toBeInTheDocument();

      await waitFor(() => {
        expect(mockCallGeminiApi).toHaveBeenCalledWith(
          expect.stringContaining('Content:\n---\nThis is a long piece of English content'),
          // API key handled by service
        );
      });

      await waitFor(() => {
        expect(screen.getByDisplayValue('Test English Title from AI')).toBeInTheDocument();
        expect(screen.getByDisplayValue('This is a test English description generated by AI.')).toBeInTheDocument();
        expect(screen.getByDisplayValue('test, english, ai, generation')).toBeInTheDocument();
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "Smart Meta Tags Generated!" }));
        expect(screen.getByText(/AI Enhanced!/i)).toBeInTheDocument();
      });
    });

    test('generates meta tags manually when button is clicked (Thai)', async () => {
        mockCallGeminiApi.mockResolvedValueOnce(mockApiResponseTh);
        render(<MetaTagsManager />);

        const thButton = screen.getByRole('button', { name: 'TH' });
        fireEvent.click(thButton); // Switch to Thai

        const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/เนื้อหาหลัก/i);
        await userEvent.type(contentTextarea, 'เนื้อหาภาษาไทยสั้นๆ'); // Short content, won't auto-trigger

        const generateButton = screen.getByRole('button', { name: /สร้าง Meta Tags ด้วย AI/i });
        fireEvent.click(generateButton);

        expect(screen.getByText(/กำลังสร้าง.../i)).toBeInTheDocument();

        await waitFor(() => {
            expect(mockCallGeminiApi).toHaveBeenCalledWith(
              expect.stringContaining('Content:\n---\nเนื้อหาภาษาไทยสั้นๆ') && expect.stringContaining('generate SEO-friendly meta tags.\n\nContent:\n---\nเนื้อหาภาษาไทยสั้นๆ\n---\n\nPlease generate the following, ensuring each is on a new line and clearly labeled:\n1.  Title: An SEO-friendly title, around 65 characters.\n2.  Description: A compelling meta description, around 150 characters.\n3.  Keywords: 5-7 relevant keywords, comma-separated.\n\nOutput format example:\nTitle: [Generated Title Here]\nDescription: [Generated Meta Description Here]\nKeywords: [keyword1, keyword2, keyword3, keyword4, keyword5]\n\nGenerate the meta tags in Thai.')
            );
          });

        await waitFor(() => {
            expect(screen.getByDisplayValue('ทดสอบหัวข้อภาษาไทยจาก AI')).toBeInTheDocument();
            expect(screen.getByDisplayValue('นี่คือคำอธิบายภาษาไทยทดสอบที่สร้างโดย AI')).toBeInTheDocument();
            expect(screen.getByDisplayValue('ทดสอบ, ภาษาไทย, เอไอ, การสร้าง')).toBeInTheDocument();
            expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "สร้าง Meta Tags สำเร็จ!" }));
        });
    });


    test('handles API key error from Gemini service', async () => {
      mockCallGeminiApi.mockRejectedValueOnce(mockApiKeyError);
      render(<MetaTagsManager />);

      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      await userEvent.type(contentTextarea, 'Content that will trigger API key error.');
      // Auto-generation should trigger due to content length

      await waitFor(() => {
        expect(screen.getByText(new RegExp(mockApiKeyError.message.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')))).toBeInTheDocument();
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
          title: "Meta Tag Generation Failed",
          description: mockApiKeyError.message,
        }));
      });
    });

    test('handles generic API error from Gemini service', async () => {
      mockCallGeminiApi.mockRejectedValueOnce(mockApiError);
      render(<MetaTagsManager />);
      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      await userEvent.type(contentTextarea, 'Content that will trigger a generic API error.');

      await waitFor(() => {
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
          title: "Meta Tag Generation Failed",
          description: mockApiError.message,
        }));
      });
    });

    test('parser handles incomplete or differently formatted Gemini response for meta tags', async () => {
        const incompleteResponse = `
Title: Incomplete Title
Keywords: keyword1, keyword2
        `; // Missing Description
        mockCallGeminiApi.mockResolvedValueOnce(incompleteResponse);
        render(<MetaTagsManager />);
        const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
        await userEvent.type(contentTextarea, 'Content for incomplete parsing test, long enough for auto-trigger.');

        await waitFor(() => {
          expect(screen.getByDisplayValue('Incomplete Title')).toBeInTheDocument();
          expect(screen.getByDisplayValue('keyword1, keyword2')).toBeInTheDocument();
          // Check for default/fallback values for missing fields
          expect(screen.getByDisplayValue('Could not extract description')).toBeInTheDocument();
        });
      });
  });

  test('copy to clipboard works', async () => {
    Object.assign(navigator, { clipboard: { writeText: jest.fn().mockResolvedValueOnce(undefined) } });
    render(<MetaTagsManager />);

    // Set some meta tags to be copied
    await userEvent.type(screen.getByLabelText(/Main Content/i), 'copy test'); // Just to enable fields
    await userEvent.type(screen.getAllByRole('textbox')[1], 'Test Title for Copy'); // Title input
    await userEvent.type(screen.getAllByRole('textbox')[2], 'Test Description for Copy'); // Description input
    await userEvent.type(screen.getAllByRole('textbox')[3], 'keyword1, keyword2'); // Keywords input

    const copyButton = screen.getByRole('button', { name: /Copy HTML Meta Tags/i });
    fireEvent.click(copyButton);

    expect(navigator.clipboard.writeText).toHaveBeenCalledWith(
      expect.stringContaining('<title>Test Title for Copy</title>') &&
      expect.stringContaining('<meta name="description" content="Test Description for Copy">') &&
      expect.stringContaining('<meta name="keywords" content="keyword1, keyword2">')
    );
    await waitFor(() => {
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "Copied!" }));
        expect(screen.getByText(/Copied!/i)).toBeInTheDocument(); // Button text changes
    });
  });
});
