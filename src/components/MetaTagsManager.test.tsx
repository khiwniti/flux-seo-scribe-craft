import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import '@testing-library/jest-dom';
import MetaTagsManager from './MetaTagsManager';
import { useToast } from '@/hooks/use-toast';
import * as geminiService from '@/lib/geminiService';
import { LanguageProvider, Language } from '@/contexts/LanguageContext'; // Import LanguageProvider
import React from 'react'; // Ensure React is in scope for JSX

// Mock lucide-react icons
jest.mock('lucide-react', () => ({
  ...jest.requireActual('lucide-react'),
  Globe: () => <div data-testid="globe-icon" />,
  Sparkles: () => <div data-testid="sparkles-icon" />,
  Wand2: () => <div data-testid="wand2-icon" />,
  Copy: () => <div data-testid="copy-icon" />,
  Check: () => <div data-testid="check-icon" />,
  CheckCircle: () => <div data-testid="checkcircle-icon" />,
  AlertTriangle: () => <div data-testid="alerttriangle-icon" />,
}));

// Mock useToast
jest.mock('@/hooks/use-toast', () => ({
  useToast: jest.fn(),
}));

// Mock geminiService
jest.mock('@/lib/geminiService');

describe('MetaTagsManager Component', () => {
  const mockToastFn = jest.fn();
  const mockCallGeminiApi = geminiService.generateBlogContent as jest.Mock;

  const renderWithLanguageProvider = (ui: React.ReactElement, language: Language = 'en') => {
    return render(
      <LanguageProvider defaultLanguage={language}>
        {ui}
      </LanguageProvider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (useToast as jest.Mock).mockReturnValue({ toast: mockToastFn });
    // Reset autoEnhanced is handled by component logic when content changes
  });

  test('renders initial elements correctly', () => {
    renderWithLanguageProvider(<MetaTagsManager />);
    expect(screen.getByText(/Smart Meta Tags Manager/i)).toBeInTheDocument(); // English default
    expect(screen.getByLabelText(/Main Content/i)).toBeInTheDocument();
    // Language buttons are now global, not in this component
    expect(screen.queryByRole('button', { name: 'EN' })).not.toBeInTheDocument();
    expect(screen.queryByRole('button', { name: 'TH' })).not.toBeInTheDocument();
  });

  test('renders Thai text for labels when language is Thai', () => {
    renderWithLanguageProvider(<MetaTagsManager />, 'th');
    expect(screen.getByText(/จัดการ Meta Tags อัจฉริยะ/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/เนื้อหาหลัก/i)).toBeInTheDocument();
  });


  test('shows error if content is empty when generate is clicked manually', async () => {
    renderWithLanguageProvider(<MetaTagsManager />);
    const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
    await userEvent.type(contentTextarea, 'short');

    const generateButton = await screen.findByRole('button', { name: /Generate Meta Tags with AI/i });

    await userEvent.clear(contentTextarea);
    fireEvent.click(generateButton);

    expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
      title: "Please enter content", // Default lang 'en' for this test
      variant: "destructive",
    }));
    expect(mockCallGeminiApi).not.toHaveBeenCalled();
  });

  describe('Gemini API Integration for Meta Tag Generation', () => {
    const mockApiResponseEn = `
Title: Test English Title from AI
Description: This is a test English description generated by AI.
Keywords: test, english, ai, generation
    `;
    const mockApiResponseTh = `
Title: ทดสอบหัวข้อภาษาไทยจาก AI
Description: นี่คือคำอธิบายภาษาไทยทดสอบที่สร้างโดย AI
Keywords: ทดสอบ, ภาษาไทย, เอไอ, การสร้าง
    `;
    const mockApiError = { message: "Network error during meta tag generation.", isApiKeyInvalid: false };
    const mockApiKeyError = { message: "API key invalid. Please go to Settings to add it.", isApiKeyInvalid: true };

    test('auto-generates meta tags on sufficient content input (English)', async () => {
      mockCallGeminiApi.mockResolvedValueOnce(mockApiResponseEn);
      renderWithLanguageProvider(<MetaTagsManager />, 'en');

      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      await userEvent.type(contentTextarea, 'This is a long piece of English content, certainly more than one hundred characters, to trigger the automatic generation of meta tags by our very smart AI system.');

      expect(screen.getByText(/Generating.../i)).toBeInTheDocument();

      await waitFor(() => {
        expect(mockCallGeminiApi).toHaveBeenCalledWith(
          expect.stringContaining('Content:\n---\nThis is a long piece of English content') &&
          expect.stringContaining('Generate the meta tags in English.')
        );
      });

      await waitFor(() => {
        expect(screen.getByDisplayValue('Test English Title from AI')).toBeInTheDocument();
        expect(screen.getByDisplayValue('This is a test English description generated by AI.')).toBeInTheDocument();
        expect(screen.getByDisplayValue('test, english, ai, generation')).toBeInTheDocument();
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "Smart Meta Tags Generated!" }));
        expect(screen.getByText(/AI Enhanced!/i)).toBeInTheDocument();
      });
    });

    test('generates meta tags manually when button is clicked (Thai)', async () => {
        mockCallGeminiApi.mockResolvedValueOnce(mockApiResponseTh);
        // Render with Thai language provider
        renderWithLanguageProvider(<MetaTagsManager />, 'th');

        // No local TH button to click anymore, language is global.
        // UI text should already be in Thai for labels if implemented for Thai in MetaTagsManager itself.
        // The test for 'renders Thai text for labels' covers this.

        const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/เนื้อหาหลัก/i); // Assuming label text changes with global lang
        await userEvent.type(contentTextarea, 'เนื้อหาภาษาไทยสั้นๆ');

        const generateButton = screen.getByRole('button', { name: /สร้าง Meta Tags ด้วย AI/i }); // Assuming button text changes
        fireEvent.click(generateButton);

        expect(screen.getByText(/กำลังสร้าง.../i)).toBeInTheDocument();

        await waitFor(() => {
            expect(mockCallGeminiApi).toHaveBeenCalledWith(
              expect.stringContaining('Content:\n---\nเนื้อหาภาษาไทยสั้นๆ') &&
              expect.stringContaining('Generate the meta tags in Thai.') // Key check for language instruction
            );
          });

        await waitFor(() => {
            expect(screen.getByDisplayValue('ทดสอบหัวข้อภาษาไทยจาก AI')).toBeInTheDocument();
            expect(screen.getByDisplayValue('นี่คือคำอธิบายภาษาไทยทดสอบที่สร้างโดย AI')).toBeInTheDocument();
            expect(screen.getByDisplayValue('ทดสอบ, ภาษาไทย, เอไอ, การสร้าง')).toBeInTheDocument();
            expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "สร้าง Meta Tags สำเร็จ!" }));
        });
    });


    test('handles API key error from Gemini service', async () => {
      mockCallGeminiApi.mockRejectedValueOnce(mockApiKeyError);
      renderWithLanguageProvider(<MetaTagsManager />);

      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      await userEvent.type(contentTextarea, 'Content that will trigger API key error.');

      await waitFor(() => {
        expect(screen.getByText(new RegExp(mockApiKeyError.message.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')))).toBeInTheDocument();
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
          title: "Meta Tag Generation Failed",
          description: mockApiKeyError.message,
        }));
      });
    });

    test('handles generic API error from Gemini service', async () => {
      mockCallGmailApi.mockRejectedValueOnce(mockApiError); // Typo: mockGmailApi -> mockCallGeminiApi
      renderWithLanguageProvider(<MetaTagsManager />);
      const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
      await userEvent.type(contentTextarea, 'Content that will trigger a generic API error.');

      await waitFor(() => {
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({
          title: "Meta Tag Generation Failed",
          description: mockApiError.message,
        }));
      });
    });

    test('parser handles incomplete or differently formatted Gemini response for meta tags', async () => {
        const incompleteResponse = `
Title: Incomplete Title
Keywords: keyword1, keyword2
        `; // Missing Description
        mockCallGeminiApi.mockResolvedValueOnce(incompleteResponse);
        renderWithLanguageProvider(<MetaTagsManager />);
        const contentTextarea = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
        await userEvent.type(contentTextarea, 'Content for incomplete parsing test, long enough for auto-trigger.');

        await waitFor(() => {
          expect(screen.getByDisplayValue('Incomplete Title')).toBeInTheDocument();
          expect(screen.getByDisplayValue('keyword1, keyword2')).toBeInTheDocument();
          expect(screen.getByDisplayValue('Could not extract description')).toBeInTheDocument();
        });
      });
  });

  test('copy to clipboard works', async () => {
    Object.assign(navigator, { clipboard: { writeText: jest.fn().mockResolvedValueOnce(undefined) } });
    renderWithLanguageProvider(<MetaTagsManager />);

    // Need to interact with elements that are present after LanguageProvider wrapping
    // The indices for getAllByRole('textbox') might change if labels are also textboxes or due to other structural changes.
    // It's safer to get them by their placeholder or current value if possible, or more specific labels.

    const contentInput = screen.getByLabelText<HTMLTextAreaElement>(/Main Content/i);
    // The inputs for title, description, keywords are identified by their current value or placeholder
    const titleInput = screen.getByPlaceholderText(/AI will generate title automatically.../i);
    const descriptionInput = screen.getByPlaceholderText(/AI will generate description automatically.../i);
    const keywordsInput = screen.getByPlaceholderText(/AI will extract keywords automatically.../i);

    await userEvent.type(contentInput, 'copy test');
    await userEvent.type(titleInput, 'Test Title for Copy');
    await userEvent.type(descriptionInput, 'Test Description for Copy');
    await userEvent.type(keywordsInput, 'keyword1, keyword2');

    const copyButton = screen.getByRole('button', { name: /Copy HTML Meta Tags/i });
    fireEvent.click(copyButton);

    expect(navigator.clipboard.writeText).toHaveBeenCalledWith(
      expect.stringContaining('<title>Test Title for Copy</title>') &&
      expect.stringContaining('<meta name="description" content="Test Description for Copy">') &&
      expect.stringContaining('<meta name="keywords" content="keyword1, keyword2">')
    );
    await waitFor(() => {
        expect(mockToastFn).toHaveBeenCalledWith(expect.objectContaining({ title: "Copied!" }));
        expect(screen.getByText(/Copied!/i)).toBeInTheDocument(); // Button text changes
    });
  });
});
